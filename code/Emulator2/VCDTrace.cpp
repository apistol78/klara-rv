/*
 Klara-RTL
 Copyright (c) 2025 Anders Pistol.

 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/
#include "Emulator2/VCDTrace.h"

using namespace traktor;

T_IMPLEMENT_RTTI_CLASS(L"VCDTrace", VCDTrace, Object)

int32_t VCDTrace::declare(const std::wstring& name)
{
	const int32_t signal = (int32_t)m_names.size();
	m_names.push_back({ name, nullptr });
	m_values.push_back(false);
	m_traces.push_back({ signal, 0, false});
	return signal;
}

int32_t VCDTrace::declare(const std::wstring& name, const std::function< bool() >& evaluator)
{
	const int32_t signal = (int32_t)m_names.size();
	m_names.push_back({ name, evaluator });
	m_values.push_back(false);
	m_traces.push_back({ signal, 0, false});
	return signal;
}

void VCDTrace::tick()
{
	for (int32_t signal = 0; signal < (int32_t)m_names.size(); ++signal)
	{
		if (m_names[signal].evaluator)
		{
			const bool value = m_names[signal].evaluator();
			set(signal, value);
		}
	}
	m_time++;
}

void VCDTrace::set(int32_t signal, bool value)
{
	if (m_values[signal] != value)
	{
		m_values[signal] = value;
		m_traces.push_back({ signal, m_time, value});
	}
}

void VCDTrace::toggle(int32_t signal)
{
	const bool value = !m_values[signal];
	m_values[signal] = value;
	m_traces.push_back({ signal, m_time, value});
}

void VCDTrace::dump(OutputStream& os) const
{
	os << L"$version Generated by Klara-RV $end" << Endl;
	os << L"$timescale 1ns $end" << Endl;

	os << L"$scope module TOP $end" << Endl;
	for (int32_t i = 0; i < (int32_t)m_names.size(); ++i)
		os << L"$var wire 1 " << (wchar_t)(L'A' + i) << L" " << m_names[i].name << L" $end" << Endl;
	os << L"$upscope $end" << Endl;

	int64_t time = -1;
	for (const auto& trace : m_traces)
	{
		if (trace.time != time)
		{
			os << L"#" << trace.time << Endl;
			time = trace.time;
		}
		os << (trace.value ? L"1" : L"0") << (wchar_t)(L'A' + trace.signal) << Endl;
	}
}
