<!--
local CHANNELS = run.commandLine:getInteger(1)
local P = function(s) output:print(s) end
--!>/*
 Klara-RTL
 Copyright (c) 2025 Anders Pistol.

 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

`timescale 1ns/1ns
`default_nettype none

module AUDIO_controller_<!-- P(CHANNELS) --!>(
	input wire i_reset,
	input wire i_clock,

	// CPU interface.
	input wire i_request,
	input wire i_rw,
	input wire [3:0] i_address,
	input wire [31:0] i_wdata,
	output bit [31:0] o_rdata,
	output bit o_ready,

	// DMA bus master
	output bit o_dma_request,
	output bit [31:0] o_dma_address,
	input wire i_dma_ready,
	input wire [31:0] i_dma_rdata,

	// Audio output
	input wire i_output_sample_clock,
	output bit [31:0] o_output_sample_rate,
	output bit [15:0] o_output_sample_left,
	output bit [15:0] o_output_sample_right
);

	initial begin
		o_ready = 1'b0;
		o_dma_request = 1'b0;
		o_output_sample_rate = 100_000_000 / (256 * 22050);
		o_output_sample_left = 16'd0;
		o_output_sample_right = 16'd0;
	end
<!--
for i = 0, CHANNELS - 1 do
--!>
	// Channel <!-- P(i) --!>
	bit ch<!-- P(i) --!>_dma_setup_request = 1'b0;
	bit ch<!-- P(i) --!>_dma_setup_append_or_replace = 1'b0;
	bit [23:0] ch<!-- P(i) --!>_dma_setup_count;
	bit [31:0] ch<!-- P(i) --!>_dma_setup_address;

	wire ch<!-- P(i) --!>_dma_request;
	wire [31:0] ch<!-- P(i) --!>_dma_address;
	bit ch<!-- P(i) --!>_dma_ready;

	wire ch<!-- P(i) --!>_busy;

	bit [15:0] ch<!-- P(i) --!>_sample_left;
	bit [15:0] ch<!-- P(i) --!>_sample_right;

	AUDIO_channel ch<!-- P(i) --!>(
		.i_reset(i_reset),
		.i_clock(i_clock),

		.i_dma_setup_request(ch<!-- P(i) --!>_dma_setup_request),
		.i_dma_setup_append_or_replace(ch<!-- P(i) --!>_dma_setup_append_or_replace),
		.i_dma_setup_count(ch<!-- P(i) --!>_dma_setup_count),
		.i_dma_setup_address(ch<!-- P(i) --!>_dma_setup_address),

		.o_dma_request(ch<!-- P(i) --!>_dma_request),
		.o_dma_address(ch<!-- P(i) --!>_dma_address),
		.i_dma_ready(ch<!-- P(i) --!>_dma_ready),
		.i_dma_rdata(i_dma_rdata),

		.o_busy(ch<!-- P(i) --!>_busy),

		.i_output_sample_clock(i_output_sample_clock),
		.o_output_sample_left(ch<!-- P(i) --!>_sample_left),
		.o_output_sample_right(ch<!-- P(i) --!>_sample_right)
	);
<!--
end
--!>
	// CPU register access.
	wire [31:0] channels_busy =
	{
		<!-- P(32 - CHANNELS) --!>'h0,
<!-- for i = 0, CHANNELS - 1 do --!>		ch<!-- P(CHANNELS - i - 1) --!>_busy<!-- if i < CHANNELS - 1 then P(",") end --!>
<!-- end --!>	};

	always_ff @(posedge i_clock) begin

<!-- for i = 0, CHANNELS - 1 do --!>		ch<!-- P(i) --!>_dma_setup_request <= 1'b0;
<!-- end --!>
		if (i_request && !o_ready) begin
			if (!i_rw) begin
				case (i_address)
					8'h00: begin
						o_rdata <= o_output_sample_rate;
						o_ready <= 1'b1;
					end
					8'h01: begin
						o_rdata <= channels_busy;
						o_ready <= 1'b1;
					end
					default:
						o_ready <= 1'b1;
				endcase
			end
			else begin
				case (i_address)
					8'h00: begin
						o_output_sample_rate <= i_wdata;
						o_ready <= 1'b1;
					end
<!--
for i = 0, CHANNELS - 1 do
--!>					8'h<!-- P(string.format("%02x", i * 2 + 1)) --!>: begin
						ch<!-- P(i) --!>_dma_setup_address <= i_wdata;
						o_ready <= 1'b1;
					end
					8'h<!-- P(string.format("%02x", i * 2 + 2)) --!>: begin
						ch<!-- P(i) --!>_dma_setup_count <= i_wdata[23:0];
						ch<!-- P(i) --!>_dma_setup_append_or_replace <= i_wdata[31];
						ch<!-- P(i) --!>_dma_setup_request <= 1'b1;
						o_ready <= 1'b1;
					end
<!--
end
--!>					default:
						o_ready <= 1'b1;
				endcase
			end
		end
		else if (!i_request) begin
			o_ready <= 1'b0;
		end
	end

	// DMA round robin scheduler
	bit [3:0] sched_channel = 0;

	always_comb begin
<!--
for i = 0, CHANNELS - 1 do
--!>		ch<!-- P(i) --!>_dma_ready = ch<!-- P(i) --!>_dma_request & i_dma_ready;
<!--
end
--!>	end

	always_ff @(posedge i_clock) begin
		o_dma_request <= 1'b0;
<!--
for i = 0, CHANNELS - 1 do
--!>
		<!-- if i > 0 then P("else ") end --!>if (sched_channel == <!-- P(i) --!>) begin
			if (ch<!-- P(i) --!>_dma_request) begin
				o_dma_request <= 1'b1;
				o_dma_address <= ch<!-- P(i) --!>_dma_address;
			end
			else
				sched_channel <= (sched_channel + 1) & <!-- P(CHANNELS - 1) --!>;
		end<!--
end
--!>
	end

	// Mixer
	always_ff @(posedge i_clock) begin
		o_output_sample_left <= <!--
			for i = 0, CHANNELS - 1 do
				if i > 0 then output:print(" + ") end
				output:print("$signed(ch" .. i .. "_sample_left)");
			end
		--!>;
		o_output_sample_right <= <!--
			for i = 0, CHANNELS - 1 do
				if i > 0 then output:print(" + ") end
				output:print("$signed(ch" .. i .. "_sample_right)");
			end
		--!>;
	end

endmodule
